let xAxis = ["a","b","c","d","e","f","g","h","i"];
let yAxis = [1,2,3,4,5,6,7,8,9];
var count = 0;
var boxRow = 0;
var board = [String: cell]();


//var linOrder = boxOrder.sorted(); // linear order
//var randOrder = boxOrder.shuffled(); // random order


// Create each cell, assign the cell position (unique), and add the cell to the board. Also create
// the rows & add a reference of each row to the containing cells.

for xVal in xAxis {
    
    var thisRow : row = row(id: "Row \(xVal)");
    
    var newCell : cell;
    
    for yVal in yAxis {
        
        let cellPosition : String = xVal + String(yVal);
        newCell = cell();
        newCell.position = cellPosition;
        newCell.thisRow = thisRow;
        thisRow.cells.append(newCell);
        board[cellPosition] = newCell;
    }
    
}

// Create the columns and add a reference of each column to the containing cells.

for yVal in yAxis {
    
    var thisCol : column = column(id: "Column \(yVal)");
    
    var cellPosition : String;
    
    for xVal in xAxis {
        cellPosition = xVal + String(yVal);
        board[cellPosition]?.thisCol = thisCol;
        thisCol.cells.append(board[cellPosition]!);
    }
}


// n is the factor size of the board. Normally set to 3, this results in a 9x9 board, 81 cells in total, standard Sudoku size.
// Create the boxes and add a reference of each box to the containing cells.

var n = 3;
var boxNum = 0;
var boxOrder : Array<String> = [];

for tots in 0...(n - 1) {
    
    var tempBox : cube;
    
    for index in 0...(n - 1) {
        
        let begin = (index * n) + 1;
        let end = (begin + n) - 1;
        
        boxNum += 1;
        tempBox = cube();
        tempBox.id = "Cube " + String(boxNum);
        
        let totsBegin = (tots*n) + 1;
        let totsEnd = (totsBegin + n) - 1;
        
        for i in totsBegin...totsEnd {
            
            var tempString : String;
            
            for j in begin...end {
                
                tempString = xAxis[i - 1] + String(yAxis[j - 1]);
                
                boxOrder.append(tempString);
                board[tempString]?.thisCube = tempBox;
                tempBox.cells.append(board[tempString]!);
                
            }
        }
    }
}

// Loop through the board and add references to siblings for each cell.
// A sibling is any cell that is contained in the same row, column or cube.


for pos in boxOrder {
    let cell = board[pos];
    let thisRow = cell?.thisRow;
    let thisCol = cell?.thisCol;
    let thisCube = cell?.thisCube;
    
    for r in thisRow!.cells {
        r.siblings.insert(pos);
    }
    for c in thisCol!.cells {
        c.siblings.insert(pos);
    }
    for b in thisCube!.cells {
        b.siblings.insert(pos);
    }
}

// Remove itself from the siblings list. A cell cannot be a sibling of itself

for pos in boxOrder {
    board[pos]?.siblings.remove(pos);
}

----------------------------------------------------------------------------------

            for value in options! {
                // if value is not in row. column or box
                inRow = cell!.thisRow!.contents.contains(value)
                inCol = cell!.thisCol!.contents.contains(value)
                inBox = cell!.thisCube!.contents.contains(value)
                
                var isValid = true
                print ("Cell is: " + cell!.position)
                var childOptions : Set<Int>?;
                
                for child in cell!.siblings {
                    
                    childOptions = board[child]?.options

                    if board[child]!.isEmpty {

                        if childOptions!.count < 2 && childOptions!.contains(value) {

                            isValid = false
                            
                        } // end if
                        
                    } // end if
                    
                } // end for


                if !inRow && !inCol && !inBox && isValid && !inserted {
                    print ("Options are: \(options!)")
                    //print (options)
                    print ("Inserting: " + String(value))
                    cell!.insert(insertValue: value)
                    
                    print ("Row Options: ")
                    print (thisRow!.getTotalOptions())
                    print ("Column Options: ")
                    print (thisCol!.getTotalOptions())
                    print ("Box Options: ")
                    print (thisBox!.getTotalOptions())
                    print("------------------------------------")
                    
                    inserted = true
                    break
                } // end if
            } // end for
            if !inserted {
                print ("Row Options: ")
                print (thisRow!.getTotalOptions())
                print ("Column Options: ")
                print (thisCol!.getTotalOptions())
                print ("Box Options: ")
                print (thisBox!.getTotalOptions())
                print("Terminating...")
                break
            } // end if

//sudoku.setCell(pos: "a1", value: 8);
//sudoku.setCell(pos: "a2", value: 4);
//sudoku.setCell(pos: "a3", value: 2);
//sudoku.setCell(pos: "b1", value: 1);
//sudoku.setCell(pos: "b2", value: 5);
//sudoku.setCell(pos: "b3", value: 3);
//sudoku.setCell(pos: "c1", value: 9);
//sudoku.setCell(pos: "c2", value: 6);
//sudoku.setCell(pos: "c3", value: 7);
//sudoku.setCell(pos: "a4", value: 5);
//sudoku.setCell(pos: "a5", value: 3);
//sudoku.setCell(pos: "a6", value: 7);

//sudoku.setCell(pos: "b4", value: 9);
//sudoku.setCell(pos: "b5", value: 7);
//sudoku.setCell(pos: "b6", value: 6);
